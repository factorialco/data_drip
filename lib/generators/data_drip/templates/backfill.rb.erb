<% if @sorbet_enabled %># typed: strict<% end %>
class <%= class_name %> < DataDrip::Backfill
<% if @sorbet_enabled %>  extend T::Sig

  Elem = type_member { { fixed: YourModel } }
  RelationType = type_member { { fixed: YourModel::RelationType } }
<% end %>
<% if @sorbet_enabled %>  sig { returns(RelationType]) }<% end %>
  def scope
    # YourModel.some_scope.where(something: true)
  end

  #######################################################
  ## YOU DON'T NEED TO IMPLEMENT BOTH METHODS          ##
  ##                                                   ##
  ## EITHER IMPLEMENT process_batch OR process_element ##
  #######################################################

  # TODO: explain if you can yse update_all use process_batch, otherwise use process_element

  # If you want to process the whole batch at once, implement this method.
  # This is useful when you can use `update_all` or similar methods.
  #
  # Example:
  # def process_batch(batch)
  #   batch.update_all(role: 'new_role')
  # end

  # If you need to process each element individually, implement this method.
  # This is useful when you need to perform more complex operations on each element.
  #
  # Example:
  # def process_element(element)
  #   element.update!(role: 'new_role')
  # end

<% if @sorbet_enabled %>  sig { params(batch: RelationType).void }<% end %>
  def process_batch(batch)
    # Process the whole batch.
    # Example: batch.update_all(column: 'something')
    raise NotImplementedError
  end

<% if @sorbet_enabled %>  sig { params(element: Elem).void }<% end %>
  def process_element(element)
    # Process each element with the changes that you need to do
    # Example: element.update!(attribute: element.other_attribute * 100)
    raise NotImplementedError
  end
end